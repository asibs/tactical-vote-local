import { GetStaticProps, GetStaticPropsContext } from 'next'
import fs from 'fs'
import path from 'path'
import { parse } from 'csv-parse'

import CouncilElection from '../../components/CouncilElection'
import WardElection from '../../components/WardElection'
import { CouncilElectionData, WardElectionData, LocalGroupsData } from '../../types'

const ELECTION_DATA_CSV = 'data/local-tactical-2023-05-04-v21.csv'

// Passed to the component - generated by GetStaticProps
interface Props {
  councilElection?: CouncilElectionData
  wardElection?: WardElectionData
}

export default function ElectionPage({ councilElection, wardElection }: Props) {
  if (councilElection) {
    // console.log("COUNCIL ELECTION", councilElection)
    return <CouncilElection data={councilElection} />
  } else if (wardElection) {
    // console.log("WARD ELECTION", wardElection)
    return <WardElection data={wardElection} />
  } else {
    return (
      <p>Oops, no council or ward, something went wrong...</p>
    )
  }
}

/* Generate the dynamic paths at /local/...
// ie. the valid values of councilSlug & wardSlug in /local/[councilSlug]/[wardSlug]
// Only called once at build-time (or per-request in dev mode)
*/
export async function getStaticPaths() {
  const paths = []

  const parser = fs
    .createReadStream(path.join(process.cwd(), ELECTION_DATA_CSV))
    .pipe(parse({ columns: true }));

  for await (const record of parser) {
    // TODO: adds duplicate council entries to `paths` which is non-ideal, but doesn't seem to cause Next.js any problems...
    paths.push({ params: { slugs: [record.council_slug] } })
    paths.push({ params: { slugs: [record.council_slug, record.ward_slug] } })
  }

  // We'll only pre-render these paths at build time.
  // { fallback: false } means any other routes should 404.
  return { paths, fallback: false }
}

/* Generate the data for statically rendering /local/[councilSlug]/[wardSlug]
// Called once at build-time for each page / value of councilSlug / wardSlug (or per-request in dev mode)
*/
export async function getStaticProps({ params }: GetStaticPropsContext<{ slugs: string[] }>) {
  const councilSlug = params?.slugs[0]
  const wardSlug = params?.slugs[1]

  if (!councilSlug) {
      return { notFound: true }
  }

  if (wardSlug) {
    // Ward-specific page
    return getWardData(councilSlug, wardSlug)
  } else {
    // Top-level council page
    return getCouncilData(councilSlug)
  }
}

async function getWardData(councilSlug: string, wardSlug: string) {
  const parser = fs
    .createReadStream(path.join(process.cwd(), ELECTION_DATA_CSV))
    .pipe(parse({
      columns: true,
      on_record: (record) => {
        if (record.council_slug === councilSlug) {
          return record
        }
        return null
      },
    }));

  let wardRecord = undefined
  let allCouncilWards = []
  for await (const record of parser) {
    if (record.ward_slug === wardSlug) {
      if (!wardRecord) {
        wardRecord = record
      } else {
        console.log(`ERROR: Found duplicate line ${record} for ${councilSlug}.${wardSlug}`)
      }
    }

    allCouncilWards.push({
      wardName: record['ward_name'],
      wardSlug: record['ward_slug'],
      seatsContested: Number(record['seats contested']),
      recommendedVote1: record['recommended vote 1 Override'] || record['recommended vote 1'],
      recommendedVote2: record['recommended vote 2 Override'] || record['recommended vote 2'],
      recommendedVote3: record['recommended vote 3 Override'] || record['recommended vote 3'],
    })
  }

  const wardElectionData = {
    councilName: wardRecord['council_name'],
    councilSlug: wardRecord['council_slug'],
    wardName: wardRecord['ward_name'],
    wardSlug: wardRecord['ward_slug'],
    totalSeats: Number(wardRecord['total seats']),
    seatsContested: Number(wardRecord['seats contested']),
    priority: Number(wardRecord['Target Priority']),
    recommendedVote1: wardRecord['recommended vote 1 Override'] || wardRecord['recommended vote 1'],
    recommendedVote2: wardRecord['recommended vote 2 Override'] || wardRecord['recommended vote 2'],
    recommendedVote3: wardRecord['recommended vote 3 Override'] || wardRecord['recommended vote 3'],
    recommendationAdvice: wardRecord['recommendation_public_notes Override'] || wardRecord['recommendation_public_notes'],
    localGroups: [
      {
        name: wardRecord['1st Parliamentary Constituency Name'],
        link: wardRecord['1st social link'],
      },
      {
        name: wardRecord['2nd Parliamentary Constituency Name'],
        link: wardRecord['2nd social link'],
      },
      {
        name: wardRecord['3rd Parliamentary Constituency Name'],
        link: wardRecord['3rd social link'],
      },
      {
        name: wardRecord['4th Parliamentary Constituency Name'],
        link: wardRecord['4th social link'],
      },
    ].filter((group) => !!group.name && !!group.link && group.name !== "#N/A" && group.link !== "#N/A"),
    allCouncilWards: allCouncilWards,
    lastElectionResultsUrl: wardRecord['Wikipedia Results'],
  }

  return { props: { wardElection: wardElectionData } }
}

async function getCouncilData(councilSlug: string) {
  const parser = fs
    .createReadStream(path.join(process.cwd(), ELECTION_DATA_CSV))
    .pipe(parse({
      columns: true,
      on_record: (record) => {
        if (record.council_slug === councilSlug) {
          return record
        }
        return null
      },
    }));

  let wardRecords = []
  let localGroups: LocalGroupsData[] = []
  for await (const record of parser) {
    wardRecords.push(record)

    const indexes = ['1st', '2nd', '3rd', '4th']
    indexes.forEach((i) => {
      const name = record[`${i} Parliamentary Constituency Name`]
      const link = record[`${i} social link`]

      if (!!name && !!link && name !== "#N/A" && link !== "#N/A") {
        if (localGroups.findIndex(x => x.name === name) === -1) {
          localGroups.push({ name: name, link: link })
        }
      }
    })
  }

  const wards = wardRecords.map((wardRecord) => {
    return {
      wardName: wardRecord['ward_name'],
      wardSlug: wardRecord['ward_slug'],
      seatsContested: Number(wardRecord['seats contested']),
      recommendedVote1: wardRecord['recommended vote 1 Override'] || wardRecord['recommended vote 1'],
      recommendedVote2: wardRecord['recommended vote 2 Override'] || wardRecord['recommended vote 2'],
      recommendedVote3: wardRecord['recommended vote 3 Override'] || wardRecord['recommended vote 3'],
    }
  })

  const councilElectionData = {
    councilName: wardRecords[0]['council_name'],
    councilSlug: wardRecords[0]['council_slug'],
    priority: Number(wardRecords[0]['Target Priority']),
    wards: wards,
    localGroups: localGroups,
    lastElectionResultsUrl: wardRecords[0]['Wikipedia Results'],
  }

  return { props: { councilElection: councilElectionData } }
}
