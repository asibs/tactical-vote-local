import { GetStaticProps, GetStaticPropsContext } from 'next'
import fs from 'fs'
import path from 'path'
import { parse } from 'csv-parse'

import CouncilElection from '../../components/CouncilElection'
import WardElection from '../../components/WardElection'
import { CouncilElectionData, WardElectionData } from '../../types'

const ELECTION_DATA_CSV = 'data/local-tactical-2023-05-04-v1.csv'

// Passed to the component - generated by GetStaticProps
interface Props {
  councilElection?: CouncilElectionData
  wardElection?: WardElectionData
}

export default function ElectionPage({ councilElection, wardElection }: Props) {
  if (councilElection) {
    // console.log("COUNCIL ELECTION", councilElection)
    return <CouncilElection data={councilElection} />
  } else if (wardElection) {
    // console.log("WARD ELECTION", wardElection)
    return <WardElection data={wardElection} />
  } else {
    return (
      <p>Oops, no council or ward, something went wrong...</p>
    )
  }
}

/* Generate the dynamic paths at /local/...
// ie. the valid values of councilSlug & wardSlug in /local/[councilSlug]/[wardSlug]
// Only called once at build-time (or per-request in dev mode)
*/
export async function getStaticPaths() {
  const paths = []

  const parser = fs
    .createReadStream(path.join(process.cwd(), ELECTION_DATA_CSV))
    .pipe(parse({ columns: true }));

  for await (const record of parser) {
    // TODO: adds duplicate council entries to `paths` which is non-ideal, but doesn't seem to cause Next.js any problems...
    paths.push({ params: { slugs: [record.council_slug] } })
    paths.push({ params: { slugs: [record.council_slug, record.ward_slug] } })
  }

  // We'll only pre-render these paths at build time.
  // { fallback: false } means any other routes should 404.
  return { paths, fallback: false }
}

/* Generate the data for statically rendering /local/[councilSlug]/[wardSlug]
// Called once at build-time for each page / value of councilSlug / wardSlug (or per-request in dev mode)
*/
export async function getStaticProps({ params }: GetStaticPropsContext<{ slugs: string[] }>) {
  const councilSlug = params?.slugs[0]
  const wardSlug = params?.slugs[1]

  if (!councilSlug) {
      return { notFound: true }
  }

  if (wardSlug) {
    // Ward-specific page
    return getWardData(councilSlug, wardSlug)
  } else {
    // Top-level council page
    return getCouncilData(councilSlug)
  }
}

async function getWardData(councilSlug: string, wardSlug: string) {
  const parser = fs
    .createReadStream(path.join(process.cwd(), ELECTION_DATA_CSV))
    .pipe(parse({
      columns: true,
      on_record: (record) => {
        if (record.council_slug === councilSlug) {
          return record
        }
        return null
      },
    }));

  let wardRecord = undefined
  let allCouncilWards = []
  for await (const record of parser) {
    if (record.ward_slug === wardSlug) {
      if (!wardRecord) {
        wardRecord = record
      } else {
        console.log(`ERROR: Found duplicate line ${record} for ${councilSlug}.${wardSlug}`)
      }
    }

    allCouncilWards.push({
      wardName: record['ward_name'],
      wardSlug: record['ward_slug'],
      seatsContested: Number(record['seats contested']),
      recommendedVote1: record['recommended vote 1'],
      recommendedVote2: record['recommended vote 2'],
      recommendedVote3: record['recommended vote 3'],
    })
  }

  const wardElectionData = {
    councilName: wardRecord['council_name'],
    councilSlug: wardRecord['council_slug'],
    wardName: wardRecord['ward_name'],
    wardSlug: wardRecord['ward_slug'],
    totalSeats: Number(wardRecord['total seats']),
    seatsContested: Number(wardRecord['seats contested']),
    priority: wardRecord['Target Priority'],
    recommendedVote1: wardRecord['recommended vote 1'],
    recommendedVote2: wardRecord['recommended vote 2'],
    recommendedVote3: wardRecord['recommended vote 3'],
    recommendationAdvice: wardRecord['recommendation_public_notes'],
    localGroups: [
      {
        name: wardRecord['1st Parliamentary Constituency Name'],
        link: wardRecord['1st social link'],
      },
      {
        name: wardRecord['2nd Parliamentary Constituency Name'],
        link: wardRecord['2nd social link'],
      },
      {
        name: wardRecord['3rd Parliamentary Constituency Name'],
        link: wardRecord['3rd social link'],
      },
      {
        name: wardRecord['4th Parliamentary Constituency Name'],
        link: wardRecord['4th social link'],
      },
    ].filter((group) => !!group.link && group.link != "#N/A"),
    allCouncilWards: allCouncilWards,
  }

  return { props: { wardElection: wardElectionData } }
}

async function getCouncilData(councilSlug: string) {
  const parser = fs
    .createReadStream(path.join(process.cwd(), ELECTION_DATA_CSV))
    .pipe(parse({
      columns: true,
      on_record: (record) => {
        if (record.council_slug === councilSlug) {
          return record
        }
        return null
      },
    }));

  let councilElectionData = undefined
  for await (const record of parser) {
    if (!councilElectionData) {
      councilElectionData = {
        councilName: record['council_name'],
        councilSlug: record['council_slug'],
        priority: record['Target Priority'], // Priority should be the same for all wards in a council!
        wards: [{
          wardName: record['ward_name'],
          wardSlug: record['ward_slug'],
          seatsContested: Number(record['seats contested']),
          recommendedVote1: record['recommended vote 1'],
          recommendedVote2: record['recommended vote 2'],
          recommendedVote3: record['recommended vote 3'],
        }],
      }
    } else {
      councilElectionData.wards.push({
        wardName: record['ward_name'],
        wardSlug: record['ward_slug'],
        seatsContested: Number(record['seats contested']),
        recommendedVote1: record['recommended vote 1'],
        recommendedVote2: record['recommended vote 2'],
        recommendedVote3: record['recommended vote 3'],
      })
    }
  }

  return { props: { councilElection: councilElectionData } }
}
